## DB 성능 개선

### DB 성능 개선 방법

DB 성능을 개선하는 방법에는 다양한 방식이 있다. SQL을 튜닝하거나, Redis와 같은 캐싱 서버를 활용하거나, replication(master/slave 구조)를 사용하거나, 메모리나 CPU 등의 하드웨어를 업그레이드하거나.. 그런데 왜 이렇게 다양한 방법들 중에서 ‘SQL 튜닝’을 가장 먼저 고려해야 할까?

<br />

### 튜닝을 하는 이유

1. SQL 튜닝을 제외한 나머지 방법은 추가적인 시스템을 구축해야 한다. 따라서 **금전적, 시간적 비용이 추가적으로 발생**한다. 조금 더 복잡해진 시스템 구조로 인해 **관리 비용이 늘어난다.** 그에 비해 **SQL 튜닝은 기존의 시스템 변경 없이 성능을 개선할 수 있다.**
2. **근본적인 문제를 해결하는 방법**이 SQL 튜닝일 가능성이 높다. **SQL 자체가 비효율적으로 작성됐다면 아무리 시스템적으로 성능을 개선한다고 하더라도 한계가 있다.** 하지만 SQL 튜닝을 통해 기본적으로 성능을 향상시킨다면, 시스템적인 성능 개선이 필요없거나 훨씬 간단한 개선으로 큰 성능 개선 효과를 얻을 수 있다.

<br />

## MySQL 구조 파악

<aside>

> **MySQL 구조 파악 이유** > <br />
> → 어떤 부분에서 MySQL의 성능을 많이 잡아 먹는지, 어떤 요인이 주로 문제를 일으키는 지 파악할 수 있어야 한다. 그 원인을 파악하기 위해서는 MySQL 구조를 알아야만 한다.

</aside>

<br />

### MySQL 아키텍처

1. 클라이언트가 DB에 SQL 요청을 보낸다.
2. MySQL 엔진에서 **옵티마이저**가 SQL문을 분석한 뒤 빠르고 효율적으로 데이터를 가져올 수 있는 계획을 세운다. 어떤 순서로 테이블에 접근할 지, 인덱스를 사용할 지, 어떤 인덱스를 사용할 지 등을 결정한다.
   **(옵티마이저가 세운 계획은 완벽하지 않다. 따라서 SQL 튜닝이 필요하다.)**
3. 옵티마이저가 세운 계획을 바탕으로 스토리지 엔진에서 데이터를 가져온다.
   **(DB 성능에 문제가 생기는 대부분의 원인은 스토리지 엔진으로부터 데이터를 가져올 때 발생한다. 데이터를 찾기가 어려워서 오래 걸리거나, 가져올 데이터가 너무 많아서 오래 걸린다. SQL 튜닝의 핵심은 스토리지 엔진으로부터 되도록이면 데이터를 찾기 쉽게 바꾸고, 적은 데이터를 가져오도록 바꾸는 것을 말한다.)**
4. MySQL 엔진에서 정렬, 필터링 등의 마지막 처리를 한 뒤에 클라이언트에게 SQL 결과를 응답한다.

<br />

### SQL 튜닝의 핵심

1. **스토리지 엔진에서 데이터를 찾기 쉽게 바꾸기**
2. **스토리지 엔진으로부터 가져오는 데이터의 양 줄이기**

<br />

> SQL 성능 개선을 위해 가장 많이 활용되는 방법이 **인덱스 활용**이다. 하지만 단순히 인덱스만 적용한다고 해서 무조건 해결되는 게 아니다. 인덱스를 **적절하게** 활용해야만 DB 성능이 개선된다.

<br />

## 인덱스란?

### 정의

- DB 테이블에 대한 검색 성능의 속도를 높여주는 자료 구조
- 데이터를 빨리 찾기 위해 **특정 칼럼을 기준으로 미리 ‘정렬’해둔 표**

<br />

### 예시

users 테이블에 1만개의 row가 있을 때, 23살인 사용자를 조회한다고 해보자. 인덱스가 없다면 만개의 데이터를 전부 찾아봐야 할 것이다. 이를 **Full Scan**이라고 한다. 그런데 만약 사전에 나이를 기준으로 데이터를 정렬해둔다면 어떨까? (1)이미 정렬되어 있기 때문에 23살 데이터의 위치를 찾기도 빠르고, (2)24살 이후의 데이터는 볼 필요가 없으므로 모든 데이터를 스캔할 필요도 없다.

<br />

### 장단점

- 장점: 조회 성능이 향상됨
- 단점: 쓰기 작업(데이터 삽입, 수정, 삭제) 성능이 저하됨

⇒ _느려지는 이유_? 인덱스를 생성한다는 것은 결국 인덱스용 테이블을 추가적으로 생성한다는 뜻이고, 쓰기 작업 시 원본 테이블뿐 아니라 인덱스 테이블에도 그 값을 반영해야 한다. 즉 두 개 이상의 테이블에서 처리가 필요하기 때문에 더 느려질 수밖에 없다. 따라서 **무분별한 인덱스 사용은 지양**해야 한다.

### 주의점

- 적절한 활용 필요

  앞서 말했듯이, 인덱스를 많이 정의한다고 무조건 좋은 것은 아니다. 향상되는 것은 조회 시의 성능일 뿐, 그 외의 쓰기 작업에서는 데이터의 수가 많아질수록 부하가 심해지므로, 인덱스 선언은 꼭 필요한 경우에만 사용해야 한다.

- 멀티 칼럼 인덱스 구성 순서

  1.  **처음에 배치된 칼럼만** 멀티 칼럼 인덱스에서 일반 인덱스처럼 활용 가능하다.
  2.  칼럼 순서는 소분류 > 중분류 > 대분류 순으로 구성하는 것이 좋다.

  정의한 칼럼의 순서에 따라서 성능 차이가 난다. 만약 (부서, 이름) 순으로 인덱스를 정의했다면, ‘인사팀’에 해당하는 데이터를 찾은 후 ‘홍길동’을 찾을 것이다. 하지만 부서는 데이터 중복도가 높기 때문에 비효율적이며, (이름, 부서)순으로 정의하는 것이 더 높은 성능을 보일 수 있다.

  즉 데이터 중복도가 낮은(≒ 카디널리티가 높은) 컬럼이 앞쪽으로 오는 게 좋은 경우가 많다. (항상 그런 것은 아니다)

<br />

## 인덱스의 종류

### 기본키(Primary Key)

- PK도 인덱스의 일종이기 때문에, 테이블의 데이터가 이 PK를 기준으로 정렬되어 보관됨
- 인덱스란 데이터를 빨리 찾기 위해 **특정 칼럼을 기준으로 미리 ‘정렬’해둔 표**라고 했는데, 그 칼럼이 PK일 경우에는 **클러스터링 인덱스**라고 부름
- 클러스터링 인덱스란 “원본 데이터” 자체가 정렬되는 인덱스를 의미함
- 클러스터링 인덱스에는 PK밖에 없기 때문에, PK = 클러스터링 인덱스 라고 봐도 무방

<br />

### 유니크(UNIQUE) 조건

- MySQL은 UNIQUE 제약 조건 설정 시 자동으로 인덱스가 생성됨
- 그 이유는 MySQL에서 유니크 조건을 구성하고 사용할 때 기본적으로 인덱스의 원리를 활용하기 때문
- 즉, 유니크 옵션을 사용한다 = 인덱스를 사용한다 = 조회 성능이 향상된다
- 유니크 특징으로 인해 생성되는 인덱스를 “고유 인덱스(Unique Index)”라고 부름

<br />

### 멀티 칼럼 인덱스(Multiple Column Index)

- 2개 이상의 칼럼을 묶어서 하나의 인덱스로 설정하는 것
- 즉 2개 이상의 칼럼에 대해서 미리 정렬해둔 표를 생성하는 것
- 여러 칼럼을 인덱스로 생성할 때에는 칼럼의 순서도 중요함. 그게 곧 정렬의 우선순위이기 때문
- (부서, 나이)로 인덱스를 생성했다면, 부서를 기준으로 먼저 정렬되고 동일 부서 내 데이터들 사이에서 나이를 기준으로 다시 정렬됨

<br />
### 커버링 인덱스(Covering Index)

- SQL문을 실행시킬 때 필요한 모든 컬럼을 갖고 있는 인덱스
- 예시

  첫 번째 쿼리는 created_at 칼럼이 인덱스에 없기 때문에 결국 원본 테이블에 접근해야 하지만, 두 번째 쿼리는 인덱스에 사용자가 요청하는 모든 데이터가 담겨있기 때문에 원본 테이블에 접근할 필요가 없다.

  ```sql
  SELECT id, created_at FROM users;
  SELECT id, name FROM users;
  ```

<br/>

## EXPLAIN 결과 TYPE 종류

### ALL(FULL TABLE SCAN)

- 인덱스를 활용하지 않고 테이블을 처음부터 끝까지 전부 탐색하는 방식
- 따라서 매우 비효율적

<br/>

### INDEX(INDEX FULL SCAN)

- 인덱스 테이블을 처음부터 끝까지 전부 탐색하는 방식
- 실제 테이블보다 크기가 작기 때문에 일반적으로 full table scan보다는 (상대적으로) 효율적
- index full scan도 결국 인덱스 테이블 전체를 읽어야 하기 때문에 상황에 따라서는 아닌 경우도 있음

<br/>

### const

- 조회하고자 하는 1건의 데이터를 단번에 찾아오는 경우
- 즉 고유 인덱스(UNIQUE)나 PK를 사용해서 1건의 데이터만 조회한 경우에 해당
- 아주 효율적인 방식임

<br/>

### range(INDEX RANGE SCAN)

- 인덱스를 활용해 범위 형태의 데이터를 조회하는 경우
- BETWEEN, 부등호(<, >, ≤, ≥), IN, LIKE이 이에 해당
- 인덱스를 사용하기 때문에 기본적으로 효율적인 방식이나, 그 범위가 넓을 경우 성능이 저하됨

<br/>

### ref

- 비고유 인덱스(UNIQUE가 아닌 칼럼의 인덱스)를 사용한 경우
- 인덱스기 때문에 정렬은 되어 있으나, 비고유기 때문에 중복된 값이 있을 수 있음

<br/>

### 기타 타입

- eq_ref
- index_merge
- ref_or_null
