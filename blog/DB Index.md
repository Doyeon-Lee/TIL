## DB 성능 개선

### DB 성능 개선 방법

DB 성능을 개선하는 방법에는 다양한 방식이 있다. SQL을 튜닝하거나, Redis와 같은 캐싱 서버를 활용하거나, replication(master/slave 구조)를 사용하거나, 메모리나 CPU 등의 하드웨어를 업그레이드하거나.. 그런데 왜 이렇게 다양한 방법들 중에서 ‘SQL 튜닝’을 가장 먼저 고려해야 할까?

<br />

### 튜닝을 하는 이유

1. SQL 튜닝을 제외한 나머지 방법은 추가적인 시스템을 구축해야 한다. 따라서 **금전적, 시간적 비용이 추가적으로 발생**한다. 조금 더 복잡해진 시스템 구조로 인해 **관리 비용이 늘어난다.** 그에 비해 **SQL 튜닝은 기존의 시스템 변경 없이 성능을 개선할 수 있다.**
2. **근본적인 문제를 해결하는 방법**이 SQL 튜닝일 가능성이 높다. **SQL 자체가 비효율적으로 작성됐다면 아무리 시스템적으로 성능을 개선한다고 하더라도 한계가 있다.** 하지만 SQL 튜닝을 통해 기본적으로 성능을 향상시킨다면, 시스템적인 성능 개선이 필요없거나 훨씬 간단한 개선으로 큰 성능 개선 효과를 얻을 수 있다.

<br />

## MySQL 구조 파악

<aside>

> **MySQL 구조 파악 이유** > <br />
> → 어떤 부분에서 MySQL의 성능을 많이 잡아 먹는지, 어떤 요인이 주로 문제를 일으키는 지 파악할 수 있어야 한다. 그 원인을 파악하기 위해서는 MySQL 구조를 알아야만 한다.

</aside>

<br />

### MySQL 아키텍처

1. 클라이언트가 DB에 SQL 요청을 보낸다.
2. MySQL 엔진에서 **옵티마이저**가 SQL문을 분석한 뒤 빠르고 효율적으로 데이터를 가져올 수 있는 계획을 세운다. 어떤 순서로 테이블에 접근할 지, 인덱스를 사용할 지, 어떤 인덱스를 사용할 지 등을 결정한다.
   **(옵티마이저가 세운 계획은 완벽하지 않다. 따라서 SQL 튜닝이 필요하다.)**
3. 옵티마이저가 세운 계획을 바탕으로 스토리지 엔진에서 데이터를 가져온다.
   **(DB 성능에 문제가 생기는 대부분의 원인은 스토리지 엔진으로부터 데이터를 가져올 때 발생한다. 데이터를 찾기가 어려워서 오래 걸리거나, 가져올 데이터가 너무 많아서 오래 걸린다. SQL 튜닝의 핵심은 스토리지 엔진으로부터 되도록이면 데이터를 찾기 쉽게 바꾸고, 적은 데이터를 가져오도록 바꾸는 것을 말한다.)**
4. MySQL 엔진에서 정렬, 필터링 등의 마지막 처리를 한 뒤에 클라이언트에게 SQL 결과를 응답한다.

<br />

### SQL 튜닝의 핵심

1. **스토리지 엔진에서 데이터를 찾기 쉽게 바꾸기**
2. **스토리지 엔진으로부터 가져오는 데이터의 양 줄이기**

<br />

> SQL 성능 개선을 위해 가장 많이 활용되는 방법이 **인덱스 활용**이다. 하지만 단순히 인덱스만 적용한다고 해서 무조건 해결되는 게 아니다. 인덱스를 **적절하게** 활용해야만 DB 성능이 개선된다.

<br />

## 인덱스란?

### 정의

- DB 테이블에 대한 검색 성능의 속도를 높여주는 자료 구조
- 데이터를 빨리 찾기 위해 **특정 칼럼을 기준으로 미리 ‘정렬’해둔 표**

<br />

### 예시

users 테이블에 1만개의 row가 있을 때, 23살인 사용자를 조회한다고 해보자. 인덱스가 없다면 만개의 데이터를 전부 찾아봐야 할 것이다. 이를 **Full Scan**이라고 한다. 그런데 만약 사전에 나이를 기준으로 데이터를 정렬해둔다면 어떨까? (1)이미 정렬되어 있기 때문에 23살 데이터의 위치를 찾기도 빠르고, (2)24살 이후의 데이터는 볼 필요가 없으므로 모든 데이터를 스캔할 필요도 없다.

<br />

### 장단점

- 장점: 조회 성능이 향상됨
- 단점: 쓰기 작업(데이터 삽입, 수정, 삭제) 성능이 저하됨

⇒ _느려지는 이유_? 인덱스를 생성한다는 것은 결국 인덱스용 테이블을 추가적으로 생성한다는 뜻이고, 쓰기 작업 시 원본 테이블뿐 아니라 인덱스 테이블에도 그 값을 반영해야 한다. 즉 두 개 이상의 테이블에서 처리가 필요하기 때문에 더 느려질 수밖에 없다. 따라서 **무분별한 인덱스 사용은 지양**해야 한다.

<br />

## 인덱스의 종류

### 기본키(Primary Key)

- PK도 인덱스의 일종이기 때문에, 테이블의 데이터가 이 PK를 기준으로 정렬되어 보관됨
- 인덱스란 데이터를 빨리 찾기 위해 **특정 칼럼을 기준으로 미리 ‘정렬’해둔 표**라고 했는데, 그 칼럼이 PK일 경우에는 **클러스터링 인덱스**라고 부름
- 클러스터링 인덱스란 “원본 데이터” 자체가 정렬되는 인덱스를 의미함
- 클러스터링 인덱스에는 PK밖에 없기 때문에, PK = 클러스터링 인덱스 라고 봐도 무방

<br />

### 유니크(UNIQUE) 조건

- MySQL은 UNIQUE 제약 조건 설정 시 자동으로 인덱스가 생성됨
- 그 이유는 MySQL에서 유니크 조건을 구성하고 사용할 때 기본적으로 인덱스의 원리를 활용하기 때문
- 즉, 유니크 옵션을 사용한다 = 인덱스를 사용한다 = 조회 성능이 향상된다
- 유니크 특징으로 인해 생성되는 인덱스를 “고유 인덱스(Unique Index)”라고 부름

<br />

### 멀티 칼럼 인덱스(Multiple Column Index)

- 2개 이상의 칼럼을 묶어서 하나의 인덱스로 설정하는 것
- 즉 2개 이상의 칼럼에 대해서 미리 정렬해둔 표를 생성하는 것
- 여러 칼럼을 인덱스로 생성할 때에는 칼럼의 순서도 중요함. 그게 곧 정렬의 우선순위이기 때문
- (부서, 나이)로 인덱스를 생성했다면, 부서를 기준으로 먼저 정렬되고 동일 부서 내 데이터들 사이에서 나이를 기준으로 다시 정렬됨
